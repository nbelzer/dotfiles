#+title: Emacs Configuration
#+AUTHOR: Nick Belzer (nickbelzer.me)
* Overview
As a newcomer to Emacs (2019-12-29) I am using this "literate
programming" approach to my Emacs configuration as described by
[[https://protesilaos.com/dotemacs][Prostesilaos Stavrou]]. This paradigm allows a combination of language and
code blocks, allowing explanation and organisation. Emacs only reads the
elisp code included.

To make this setup work the original =init.el= has to contain a little
boilerplate such that it can load in the required packages and load this
actual file. For reference it is shown below:

#+begin_example emacs-lisp
(require 'package)

(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/"))

;; Initialise the packages, avoiding a re-initialisation.
(unless (bound-and-true-p package--initialized)
  (setq package-enable-at-startup nil)
  (package-initialize))

;; Make sure `use-package' is available.
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

;; Configure `use-package' prior to loading it.
(eval-and-compile
  (setq use-package-always-ensure nil)
  (setq use-package-always-defer nil)
  (setq use-package-always-demand nil)
  (setq use-package-expand-minimally nil)
  (setq use-package-enable-imenu-support t)
  (setq use-package-compute-statistics t)
  (setq use-package-hook-name-suffix nil))

(eval-when-compile
  (require 'use-package))

(use-package vc
  :config
  (setq vc-follow-symlinks t)) ; Because my dotfiles are managed that way

(use-package org)

(let* ((conf "~/.emacs.d/emacs-init")
       (el (concat conf ".el"))
       (org (concat conf ".org")))
  (if (file-exists-p el)
      (load-file el)
    (org-babel-load-file org)))
#+end_example

Code blocks, which include the configuration elisp code, have to be
wrapped in =#+BEGIN_SRC= and =#+END_SRC= tags. These can be quickly
inserted by the keyboard command =<s TAB=.

** Prepare use-package
[[https://github.com/jwiegley/use-package][use-packages]] is a tool that helps streamline the configuration of
packages in a performance-orientated way. It allows code to be executed
before loading (=:init=) and after loading (=:config=) and more while
keeping the loading and configuration together.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-when-compile
  (require 'use-package))
#+END_SRC

** Rebuild init and refresh package cache
Derided from the dotemacs from [[https://protesilaos.com/dotemacs/#h:b343378b-d3ec-4c90-8117-6cf92abee45b][Protesilaos]] I like to rebuild my init file on Emacs exit, together with refreshing the package cache.

#+BEGIN_SRC emacs-lisp
(defun prot/rebuild-emacs-init ()
  "Produce Elisp init from my Org dotemacs.
Add this to `kill-emacs-hook', to use the newest file in the next
session.  The idea is to reduce startup time, though just by
rolling it over to the end of a session rather than the beginning
of it."
  (interactive)
  (declare-function org-babel-tangle-file "ob-tangle")
  (let ((init-el "~/.emacs.d/emacs-init.el")
        (init-org "~/.emacs.d/emacs-init.org"))
    (when (file-exists-p init-el)
      (delete-file init-el))
    (org-babel-tangle-file init-org init-el)
    (byte-compile-file init-el)))

(use-package emacs
  :config
  :hook ((kill-emacs-hook . prot/rebuild-emacs-init)))
#+END_SRC
** Where I run Emacs
I run Emacs on macOS as I use a mac as my day-to-day system. Therefore
this configuration will be optimised for running Emacs on macOS.

** COPYING
This configuration is made by me (Nick Belzer), it is designed for my
systems. I cannot guarantee that my configuration works for you or on
your machine. However if you are interested in some parts of this
configuration, feel free to try it out and ask questions.

*** COPYRIGHT NOTICE
Copyright (c) 2020 Nick Belzer <me@nickbelzer.me>

This file is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file.  If not, see <http://www.gnu.org/licenses/>.
* Keyboard Shortcuts
One of the primary reasons for using Emacs is the configuration it
offers compared to traditional text editors. Because of this I will make
extensive use of this configuration to modify the keyboard shortcuts
when I see an opportunity to improve ergonomics. I feel like this is
extremely important for someone who spends a lot of time on a computer.

** Control & Meta Rebinding
One of the primary keys used in Emacs is =C= (control) together with the =M= (meta) key. I'm not a fan of using the actual control button on the keyboard as it requires a lot of use of the pinky finger. Therefore I remap this key the =CMD= (command) key which can be pressed by the stronger thumb. The meta key is triggered by =ESC= which is bound to my =Caps Lock= key using the macOS keyboard preferences. I add an additional trigger for the meta key on the right command for when I'm using my mac based keyboard.

Based on these resources:
 - [[https://nickdrozd.github.io/2019/12/28/emacs-mac-mods.html][Modified Emacs Mac Modifiers]]
 - [[https://www.reddit.com/r/emacs/comments/91qz7l/mac_emacs_and_hyper_key/][Reddit Discussion on Hyper key]]

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
   (setq ns-command-modifier 'control)
   (setq ns-control-modifier 'meta))
#+END_SRC

** Default keys
Binding =C= to my command key does clash with some default macOS commands like cut, paste or undo. So these need new bindings.

*** Kill region or line
I rebind the =C-k= shortcut to either kill-line if nothing is selected
or kill-region if I made a selection before. This makes the kill command
'smart' as it will take it's context in to account. The same applies for
using =M-k= which will not delete but copy the selected region or line.

#+BEGIN_SRC emacs-lisp
  (defun nbelzer/kill-region-or-line ()
    "Kills the current region if selected, else kills the current line"
    (interactive)
    (if (region-active-p)
        (progn
          (kill-region (region-beginning) (region-end))
          (message "Killed region"))
        (progn
          (kill-line)
          (message "Killed line"))))

  (defun nbelzer/copy-region-or-line ()
    "Copies the current region if selected, else copies the current line"
    (interactive)
    (if (region-active-p)
        (progn
          (kill-ring-save (region-beginning) (region-end))
          (message "Copied region"))
      (progn
        (kill-ring-save (line-beginning-position) (line-end-position))
        (message "Copied line"))))

  (use-package emacs
    :bind (("C-k" . nbelzer/kill-region-or-line)
           ("M-k" . nbelzer/copy-region-or-line)))
#+END_SRC

*** Marking
Since marking by default is set to =C-SPC= we have a conflict in macOS
with the default spotlight (or Alfred) binding which I use to start
apps. So to enable marking again I use =M-SPC= instead.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :bind (("M-SPC" . set-mark-command)))
#+END_SRC

*** Copy & Paste
Killing and yanking works together with the macOS clipboard. If I want
to copy some text into Emacs I can simply copy it and use =C-y= to yank
it into Emacs. When killing or copying a region/line in Emacs it
automatically becomes available in macOS to be used outside of Emacs.

As mentioned above I set up =C-k= to kill and =M-k= to save to the kill
ring (kill without removing the selection). No special setup is required
to set this up further.

*** Buffer Navigation
To navigate within a buffer I use the default keybindings provided by
Emacs: =C-p=, =C-n=, =C-f= and =C-b= for single characters, =M-f= and
=M-b= for jumping across words.

To be able to jump through =camelCase= words when programming I enable
=subword-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package subword
    :defer t
    :hook (prog-mode-hook . subword-mode))
#+END_SRC

*** Window Navigation
To easily navigate between different buffers I've set up some keyboard shortcuts.
#+BEGIN_SRC emacs-lisp
(use-package emacs
  :bind (("C-'" . next-buffer)
         ("C-." . previous-buffer)
         ("C-o" . other-window)
         ("C-w" . kill-current-buffer)))
#+END_SRC

In addition to keybindings for buffer navigation it useful to have Emacs highlight the cursor position upon switching buffers. This is exactly what [[https://github.com/Malabarba/beacon][beacon]] does.
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :defer t
  :config
  (beacon-mode 1)
  (setq beacon-color "#E9D5FF")
  (setq beacon-size 30))
#+END_SRC

** Which-key
[[https://github.com/justbur/emacs-which-key][which-key]] provides hints for which keys can be pressed given a certain
timeout. This seems like a package that will help me explore more
keybindings as a beginner.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
    ; Enable which-key mode, which by default uses the window-bottom
    ; option
    (which-key-mode 1))
#+END_SRC
* Emacs configuration
** Window
*** Disable GUI components
As described in the 'Where I run Emacs' session I use the GUI version of
Emacs that comes in it's own window. However I prefer not to use any of
the default gui elements that come with it. Therefore these I disable
elements such as: =use-file-dialog=, =menu-bar-mode=, and
=scroll-bar-mode=.

 + The default startup screen is disabled since it loses its
   usefulness once you get familiar with the basics.
 + The frame title is set to the buffer name.
 + The initial scratch message is set to an empty message.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :custom
  ; Disable the default OS file picker.
  (use-file-dialog nil)
  ; Disable the default OS dialog for questions.
  (use-dialog-box nil)
  ; Disable the default splash screen.
  (inhibit-splash-screen t)
  ; Disable the startup screen.
  (inhibit-startup-screen t)
  ; Make sure the *scratch* buffer is blank.
  (initial-scratch-message "")
  :config
  ; Set fringe mode to left-only.
  (fringe-mode '(0 . 0))
  ; Disable the menu-bar.
  (menu-bar-mode -1)
  ; Disable to the tool-bar.
  (tool-bar-mode -1)
  ; Disable scroll bars.
  (scroll-bar-mode -1)
  ; Set the frame-title to the buffer name.
  (setq-default frame-title-format '(""))
  ; Make the titlebar transparent.
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t)))
#+END_SRC

*** Window transform
#+BEGIN_SRC emacs-lisp
(use-package emacs
  :config
  ; Set default window height to 50.
  (add-to-list 'default-frame-alist '(height . 40))
  (add-to-list 'default-frame-alist '(width . 80)))
#+END_SRC
*** Tab Bar
The tab bar (Emacs 27+) allows the different workspace layouts per tab. This is quite useful. However the native tab bar is currently not enabled on macOS.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :custom
  ; Always hide the Tab Bar (as it is not enabled for macOS).
  (tab-bar-show f))
#+END_SRC

I set up a custom keymap, given the prefix =C-,= for navigation of tabs and buffers. There is no explicit reason for the use of this prefix.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :config
  (define-prefix-command (make-symbol "C-,"))
  :bind (("C-, t" . tab-bar-switch-to-tab)
         ("C-, b" . bufler-switch-buffer)
         ("C-, p" . project-find-file)))
#+END_SRC

*** Mode line
I'm not a big fan of the clutter of minor-modes shown in the
mode-line.  Knowing which modes are enabled hasn't helped me unless I'm
messing around with a new package.  This is not enough of an argument to
keep the mode line filled in, which is why I disable it.

#+BEGIN_SRC emacs-lisp
(use-package emacs)
;;  :custom
;;  (mode-line-format nil))
#+END_SRC

** Typeface
*** Font
I use the Jetbrains Mono font as a default for Emacs. Default size of 15 as I prefer my font to be a bit bigger.

Next to this I am using a custom font for =variable-pitch= as this allows me to have a normal spaced font for text in org mode buffers. This is based on [[https://www.youtube.com/watch?v=Oiu3LFK_rX8][this video from protesilaos]]. To make this work correctly with inline code the font sizes should be tested an relatively similar. It is possible that the behaviour does not work with your theme. If you are encountering issues try using the modus themes from Protesilaos.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :custom
  (x-underline-at-descent-line t)
  (underline-minimum-offset 1)
  ; Use a slightly more relaxed line height to ease display.
  (line-spacing 0.4)
  :config
  (set-face-attribute 'default nil :font "Iosevka Comfy-14")
  (set-face-attribute 'fixed-pitch nil :font "Iosevka Comfy-14")
  (set-face-attribute 'org-block nil :font "Iosevka Comfy-14")
  (set-face-attribute 'org-table nil :font "Iosevka Comfy-14")
  (set-face-attribute 'org-date nil :font "Iosevka Comfy-14")
  (set-face-attribute 'org-meta-line nil :font "Iosevka Comfy-14")
  (set-face-attribute 'variable-pitch nil :font "Iosevka Aile-14")
  (set-face-attribute 'org-level-1 nil :font "Iosevka Aile-15" :weight 'bold)
  (set-face-attribute 'org-level-2 nil :font "Iosevka Aile-15" :weight 'bold)
  (set-face-attribute 'org-level-3 nil :font "Iosevka Aile-15" :weight 'bold)
  ; Enable variable pitch mode in org and markdown buffers.
  :hook ((org-mode-hook . variable-pitch-mode)
         (markdown-mode-hook . variable-pitch-mode)))
#+END_SRC

*** Parentheses
Highlight paratheses with no delay.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :custom
  (show-paren-delay 0)
  (show-paren-style 'mixed)
  (show-paren-ring-bell-on-mismatch t)
  :config
  (show-paren-mode 1))
#+END_SRC

*** Theme
I use the [[https://gitlab.com/protesilaos/modus-themes][modus-themes]] from Protesilaos Stavrou for their compatibility
and great accessibility. By default I load the light theme.

#+BEGIN_SRC emacs-lisp
(use-package modus-themes
  :ensure
  :init
  (modus-themes-load-themes)
  :config
  (modus-themes-load-operandi))

(defun nbelzer/apply-theme (appearance)
  "Load these, taking current system APPEARANCE into consideration."
  (mapc #'disable-theme custom-enabled-themes)
  (pcase appearance
    ('light (load-theme 'modus-operandi t))
    ('dark (load-theme 'modus-vivendi t))))

(add-hook 'ns-system-appearance-change-functions #'nbelzer/apply-theme)
#+END_SRC

** Buffer Management
I stumbled upon this package: [[https://github.com/alphapapa/bufler.el][bufler]] which /is like a butler for your
buffers/. It allows organisation of buffers based on rules (like a
specific workspace). It also plays nicely with the =tab-bar-mode=
introduced in Emacs 27.

#+BEGIN_SRC emacs-lisp
(use-package bufler
  :ensure t
  :custom
  ; Enable bufler-mode on startup.
  (bufler-mode))
#+END_SRC

** Indentation
By default I like a tab width of 4 as it matches the default in most
editors. This makes the appearence of text and code similar.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    ; First try to indent the current line, then use tab to complete at
    ; point.
    (setq-default tab-always-indent 'complete)
    (setq-default tab-width 4)
    ; Use spaces over tabs.
    (setq-default indent-tabs-mode nil))
#+END_SRC

** Line length
Based on personal preference I like a small line length. In Emacs I
typically prefer a column count of 72.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (fill-column 72)
    ; When we fill paragraph we want the command to take into account
    ; sentences (which end with a period).
    (sentence-end-without-period nil)
    :config
    ; Show the column number in the mode line.
    (column-number-mode))
#+END_SRC

In plain text mode I setup Emacs to automatically format fill
paragraphs.
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config
    (setq adaptive-fill-mode t))
;    :hook (text-mode-hook . (lambda ()
;                              (turn-on-auto-fill))))
#+END_SRC

** Delete trailing spaces
Trailing whitespace should automatically be removed before saving.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :hook (before-save-hook . delete-trailing-whitespace))
#+END_SRC

** Scrolling Behaviour
I want Emacs to help me keep focus of the cursor when scrolling.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :custom
  ; Preserve the screen position as much as possible during scrolling.
  (scroll-preserve-screen-position 1)
  (scroll-step 2)
  ; Keep a margin of 1 lines at the bottom when scrolling.
  (scroll-margin 2))
#+END_SRC

** Backups
As outlined by [[https://stackoverflow.com/questions/151945/how-do-i-control-how-emacs-makes-backup-files][ymf3 in this stackoverflow thread]] Emacs backups are
great, however it is not so great when they are in the way or clutter
your working directories. This can be resolved by setting a custom
folder for your backups.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (backup-directory-alist `(("." . "~/.emacs.backups")))
    (backup-by-copying t)
    (delete-old-versions t)
    (kept-new-versions 6)
    (kept-old-versions 2)
    (version-control t))
#+END_SRC
** Startup Time
To keep Emacs speedy (especially during startup) I followed a few tricks
described by [[https://blog.d46.us/advanced-emacs-startup/][Joe Schafer]]. This piece of code displays a message on
startup that shows how quickly Emacs was ready.

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+END_SRC

Running a speed test (see next code block) the theoretical fastest I
could load Emacs is =0.7s=. With current optimisations I achieve about
=2.22s= so there is definitely some extra room for improvement however,
given the tiny amount of time spent I am quite happy with this speedup
time.

** Dired
Dired is a great package (included in Emacs) to browse files. Some
tweaks make it even better:
+ Delete files by moving them to the trash.
+ Enable recursive deletes and copies by default.
+ Customize the display format:
  + Show all files except =.= and =..= (=-A=),
  + Show appropriate symbol for the type of file (=-F=),
  + Show human readable file sizes (=-h=).
+ Hide file details by default (=dired-hide-details-mode=).
+ Use line highlighting (=hl-line-mode=)
#+BEGIN_SRC emacs-lisp
(use-package dired
  :custom
  (dired-use-ls-dired nil)
  (delete-by-moving-to-trash t)
  (dired-recursive-copies 'always)
  (dired-recursive-deletes 'always)
  ; Customize the listing to hide . and .. (-A), show sizes in human
  ; readable format (-h), and show the appropriate symbol for the
  ; type of file/directory (see ls man page).
  (dired-listing-switches "-lAFh")
  ; By default hide details on each file highlight the entire line.
  :hook (dired-mode-hook . dired-hide-details-mode)
        (dired-mode-hook . hl-line-mode))
#+END_SRC

* macOS Specific
** Emoji Support
As defined by [[https://github.crookster.org/emacs27-from-homebrew-on-macos-with-emoji/][David Crook]] this snippet allows the use of Emojis in Emacs 🚀.

#+BEGIN_SRC emacs-lisp
;;; Useful for https://github.com/dunn/company-emoji
;; https://www.reddit.com/r/emacs/comments/8ph0hq/i_have_converted_from_the_mac_port_to_the_ns_port/
;; not tested with emacs26 (requires a patched Emacs version for
;; multi-color font support)
(if (version< "27.0" emacs-version)
    (set-fontset-font
     "fontset-default" 'unicode "Apple Color Emoji" nil 'prepend)
  (set-fontset-font
   t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend))

(use-package company-emoji
  :init
  (defun remove-company-emoji ()
    (make-local-variable 'company-backends)
    (setq company-backends (delete 'company-emoji company-backends)))
  :custom
  (company-emoji-insert-unicode nil)
  :hook
  (python-mode-hook . remove-company-emoji))
#+END_SRC
** Fix folder access
When using the default Emacs cask from brew on macOS 11 I ran in to some
problems with respect to accessing iCloud folders. The issue could not
be fixed by applying the "Full Disk Access" permission in the Security &
Preferences panel in System Prefences. This is related the installed
Emacs version being a script that checks the architecture of the machine
and runs the appropriate binary. Because of this we either need to give
the permission to the correct binary or update the =.app= such that it
directly opens the binary as explained in this article: [[https://spin.atomicobject.com/2019/12/12/fixing-emacs-macos-catalina/][Fixing Emacs
after an Upgrade]].

#+BEGIN_EXAMPLE bash
# Since MacOS Catalina the binary that is likely to launch (at least on
# my machine) is located in the Emacs-x86_64-10_14/ folder. This could
# be different on a new machine (perhaps running Apple Silicon).

# First step is actually make that binary the one that is started.
cd /Applications/Emacs.app/Contents/MacOS
mv Emacs Emacs-launcher
mv Emacs-x86_64-10_14 Emacs

# As we changed the binary that is launched the code signature is no
# longer valid. Therefore we should remove it.
rm -rf /Applications/Emacs.app/Contents/_CodeSignature
#+END_EXAMPLE

** Fix $PATH
By default the PATH variable used in Emacs does not reflect the one used
in the terminal. This is fixed by the [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] package.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :init
    (exec-path-from-shell-initialize))
#+END_SRC
* Ivy, Counsel, Prescient and Ivy-rich
[[https://github.com/abo-abo/swiper][Ivy]] is a generic completion mechanism for emacs, I use it to enhance the
minibuffer experience. Counsel is used to remap default built-in Emacs
functions to ones that are customized with more keybindings. Prescient
is used keep track of frequently used items present lists in ivy based
on this. Ivy-rich enhances some of the ivy-counsel menus with more
information in the otherwise empty space.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :defer 1
    :ensure t
    :custom
    ; Show recently used files in switch buffer
    (ivy-use-virtual-buffers t)
    (ivy-display-style 'fancy)
    :config
    (ivy-mode 1))

  (use-package counsel
    :defer 1
    :ensure t
    :after ivy)

  (use-package prescient
    :defer 1
    :ensure t
    :custom
    (prescient-history-length 50)
    (prescient-save-file "~/.emacs.d/prescient-items")
    (prescient-filter-method '(fuzzy initialism regexp))
    :config
    (prescient-persist-mode 1))

  (use-package ivy-prescient
    :defer 1
    :ensure t
    :after (prescient ivy)
    :custom
    (ivy-prescient-enable-filtering t)
    (ivy-prescient-enable-sorting t)
    :config
    (ivy-prescient-mode 1))

  (use-package ivy-rich
    :defer 2
    :ensure t
    :after ivy
    :config
    (ivy-rich-mode 1))
#+END_SRC

* Snippets
Snippets are a great way to reduce the amount of repetitive work to be
done. An example being defining images in org-mode. By using
[[https://github.com/joaotavora/yasnippet][yasnippet]] we can define snippets with custom variables.

Yasnippet no longer bundles snippets but we can take inspiration from [[http://andreacrotti.github.io/yasnippet-snippets/snippets.html][this
great collection of existing snippets]] to build our own.

#+begin_src emacs-lisp
(use-package yasnippet
  :ensure
  :defer 1
  :custom
  (yas-snippet-dirs '("~/.emacs.d/snippets"))
  :config
  (yas-global-mode 1))
#+end_src

* Programming
** Linting
*** Flycheck
[[https://flycheck.org][Flycheck]] is used for syntax checking with support for many different
programming languages out of the box.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :defer t
    :ensure t
    :custom
    ; Check syntax on save.
    (flycheck-check-syntax-automatically '(save mode-enabled)))

  (use-package flycheck-indicator
    ; Show flycheck messages on the modeline.
    :defer t
    :ensure t
    :after flycheck
    :hook (flycheck-mode-hook . flycheck-indicator-mode))
#+END_SRC

** Programming mode
Some defaults I like to apply in programming mode:
+  Show line numbers in a prettified format.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
     :custom
     (linum-format "%3d ")
     :hook (prog-mode-hook . display-line-numbers-mode))
#+END_SRC

** Language Server Protocol (LSP)
The language server protocol opens Emacs up to simple code comprehension and autocomplete features such as:
 + Clever autocomplete (based on types)
 + Find references/definitions
 + Clever renaming

#+BEGIN_SRC emacs-lisp
; Should increase the amount of data emacs can read from processes to support larger language server responses.
(setq read-process-output-max (* 1024 1024)) ;; 1mb

(use-package lsp-mode
  :ensure t
  :defer t
  :init
  ; Inform lsp-mode about what language is used in an .html.erb file.
  (with-eval-after-load 'lsp-mode
    (add-to-list 'lsp-language-id-configuration
                 '(".*\\.html?.erb$" . "html")))
  :custom
  ; Set flycheck as the default diagnostic package.
  (lsp-diagnostic-package :flycheck)
  ; Disable the modeline diagnostics.
  (lsp-modeline-diagnostics-enable nil)
  ; Disable headerline with breadcrumbs.
  (lsp-headerline-breadcrumb-enable nil)
  ; Make sure that we always call lsp-deferred to avoid long
  ; periods of unresponsiveness.
  :commands (lsp lsp-deferred)
  :hook ((ruby-mode-hook . lsp)
           (web-mode-hook . lsp)))
#+END_SRC

*** Ruby
In addition to Solargraph support through LSP we can improve our experience with Ruby by using [[https://github.com/rodimius/emacs-ruby-electric/blob/master/ruby-electric.el][ruby-electric]]. This mode automatically closes different modules like =def=, =if=, =for=, etc.

#+BEGIN_SRC emacs-lisp
(use-package ruby-electric
  :defer t
  :ensure t
  :hook ((ruby-mode-hook . ruby-electric-mode)))

(defun switch-to-test-buffer (buf strg)
    (switch-to-buffer-other-window "*compilation*")
    (read-only-mode)
    (goto-char (point-max))
    (local-set-key (kbd "q")
                   (lambda () (interactive) (quit-restore-window))))

(use-package ruby-test-mode
  :defer t
  :ensure t
  :hook ((ruby-mode-hook . ruby-test-mode)
         ('compilation-finish-functions . switch-to-test-buffer)))
#+END_SRC
*** Python
Python can work using the =pyls= which needs to be installed using
pip. By default we start lsp when opening python mode.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook (python-mode-hook . lsp))
#+END_SRC

Python uses a global environment but can also be configured using
virtual environments. Using =pyvenv= I can tap in to the right
virtualenv for each project such that lsp mode understands the packages
that I have installed.

#+BEGIN_SRC emacs-lisp
  (use-package pyvenv
    :defer t
    :ensure t)
#+END_SRC

To use the Microsoft language server we need to install a separate package.

#+BEGIN_SRC emacs-lisp
(use-package lsp-python-ms
  :ensure t
  :defer t
  :init
  (setq lsp-python-ms-auto-install-server t)
  (setq lsp-python-ms-python-executable "/usr/local/bin/python3")
  :hook (python-mode-hook . (lambda ()
                              (require 'lsp-python-ms)
                              (lsp))))
#+END_SRC

*** Swift
LSP mode for Swift uses the sourcekit-lsp by Apple, this comes installed
with XCode.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-sourcekit
    :defer t
    :ensure t)
  (use-package swift-mode
    :defer t
    :ensure t
    :hook (swift-mode-hook . lsp))
#+END_SRC
*** Golang
Golang uses [[https://github.com/golang/tools/tree/master/gopls][gopls]] which has some recommendations for the [[https://github.com/golang/tools/blob/master/gopls/doc/emacs.md][Emacs setup]].

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :defer t
    :ensure t)

  (use-package lsp-mode
    :defer t
    :ensure t
    :after go-mode
    :hook (go-mode-hook . lsp-deferred))

  ;; Set up before-save hooks to format buffer and add/delete imports.
  ;; Make sure you don't have other gofmt/goimports hooks enabled.
  (defun lsp-go-install-save-hooks ()
    (add-hook 'before-save-hook #'lsp-format-buffer t t)
    (add-hook 'before-save-hook #'lsp-organize-imports t t))
  (add-hook 'go-mode-hook #'lsp-go-install-save-hooks)
#+END_SRC

** Company Mode
To enhance the autocomplete experience we use [[https://company-mode.github.io][company-mode]] to provide completion at point.

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
;  (add-to-list 'company-backends 'company-ispell)
  (setq company-global-modes '(not org-mode markdown-mode latex-mode))
  :hook (after-init-hook . global-company-mode))
(use-package company-box
  :ensure t
  :after lsp-mode)
#+END_SRC
** Debug Adapter Protocol (DAP)
The debug adapter protocol is the equivalent of the language server
protocol for debugging applications.

#+BEGIN_SRC emacs-lisp
(use-package dap-mode
  :defer t
  :ensure t)
#+END_SRC

*** Golang
To get DAP mode working for Golang we need to follow the following steps
based on the [[https://emacs-lsp.github.io/dap-mode/page/configuration/#go][dap-mode documentation]].
+ After installing =dap-mode=, run =dap-go-setup=. This will install the
  VSCode Go extension which includes =goDebug.js=, that is currently still
  required. A proper dap-mode server [[https://github.com/emacs-lsp/dap-mode/issues/318][seems to be in the works]].
+ Next to this we also need to install =delve= which is the debugger tool
  for golang. It can be installed, [[https://github.com/go-delve/delve/blob/master/Documentation/installation/osx/install.md][per instructions]], by running =go get
  github.com/go-delve/delve/cmd/dlv=.
+ After this all is ready to debug your go programs, however you will
  need to setup a proper =launch.json= to run your code via =dap-debug=.

After some more research I found out that I can actually use =go-delve=
directly using the =go-dlv= package. This allows me to use the grand
unified debugger (GUD) which supports different types of debuggers. This
uses a simpler approach as it provides you access to a (dlv) terminal
while showing the code in a separate buffer.

While reading about [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html#Debuggers][GUD]] there seems to be a lot of configuration
available and I will spend some time with it before choosing either this
or dap-mode.

** Git
As my git client I use the amazing magit.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :defer t
    :ensure t
    :custom
    ; Show fine differences for the current diff hunk only, used to
    ; minimize space used on screen.
    (magit-diff-refine-hunk t)
    :bind (("C-c g" . magit-status)))
#+END_SRC

** Zen mode
I prefer to have a simplified mode where the content on my screen is in
focus.

#+BEGIN_SRC emacs-lisp
  (use-package olivetti
    :ensure
    :defer t
    :diminish
    :config
    ; Set the default body width to the recommened 65 characters.
    (setq olivetti-body-width 65)
    (define-minor-mode nbelzer/zen-mode
      "Toggle zen-mode in the current buffer."
      :init-value nil
      :global nil
      (if nbelzer/zen-mode
          (progn
            (olivetti-mode 1)
            (message "Enabled Zen Mode"))
        (progn
          (delete-other-windows)
          (olivetti-mode -1)
          (message "Disabled Zen Mode"))))
    :bind ("C-c z" . nbelzer/zen-mode)
    :hook (org-mode-hook . olivetti-mode))
#+END_SRC
** Racket
I use the racket language for going through SICP. Set it up according to
[[https://github.com/DEADB17/ob-racket][this]] repository. I use [[https://www.racket-mode.com/#Install-Racket-Mode][racket-mode]] as major mode for editing racket files.

#+BEGIN_SRC emacs-lisp
; Allows emacs to find our ob-racket.el file.
(add-to-list 'load-path "~/.emacs.d/lisp/")

(use-package ob-racket
  :after org
  :pin manual
  :defer t
  :commands
  (org-babel-execute:racket
   org-babel-expand-body:racket))

; Racket-mode enables highlighting
(use-package racket-mode
  :ensure t
  :defer t)
#+END_SRC

I have installed racket through =brew install minimal-racket=. To support
the custom [[https://docs.racket-lang.org/sicp-manual/SICP_Language.html][SICP language]] in racket you can install it using the
following command:
#+BEGIN_EXAMPLE bash
raco pkg install sicp
#+END_EXAMPLE

** GraphQL
#+BEGIN_SRC emacs-lisp
(use-package graphql-mode
  :ensure t
  :defer t
  :mode "\\.gql\\'")
#+END_SRC

** Docker
#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :ensure t
  :defer t
  :mode "\\.Dockerfile\\'")
#+END_SRC
** YAML
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
  :defer t
  :mode "\\.ya?ml\\'")
#+END_SRC
** HTML
For editing HTML I am currently using [[https://web-mode.org][web-mode]] as it seems to be the
most popular package for this.

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode ("\\.html?\\'" "\\.svelte\\'" "\\.erb\\'" "\\.antlers\\'" "\\.php\\'"))
#+END_SRC
** CSS
I often use [[https://tailwindcss.com][TailwindCSS]] as the main library to write my HTML styling in, TailwindCSS offers a language server that I can hook into =lsp-mode= using a package by [[https://github.com/merrickluo/][merrickluo]], named [[https://github.com/merrickluo/lsp-tailwindcss][lsp-tailwindcss]].

#+BEGIN_SRC emacs-lisp
(use-package lsp-tailwindcss
  :ensure t)
#+END_SRC

In addition to this we need to run =M-x lsp-install-server=, then select =tailwindcss=.

* Org mode
** Keybindings
One of the keybindings I use often is =C-,= which opens a buffer to either
buffer or tab navigation. However in org-mode this is bound to some
action on agenda files.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :bind (:map org-mode-map
              ("C-'" . nil)))
#+END_SRC

** Content
In org mode I prefer my content to be centered using =olivetti-mode= by
default.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :hook (org-mode-hook . olivetti-mode)
  :custom
  (org-return-follows-link t)
  (org-startup-folded t))
#+END_SRC

** Headers
To make my headers stand out from the default =* Header1= or =** Header
2= I use =org-superstar=.

#+BEGIN_SRC emacs-lisp
(use-package org-superstar
  :ensure
  :after org
  :defer t
  :custom
  (org-superstar-remove-leading-stars t)
;  (setq org-superstar-headline-bullets-list
;        '("" "◉" "○" "▷"))
  (org-superstar-item-bullet-alist
        '((?+ . ?•)
          (?* . ?➤)
          (?- . ?-)))
  :hook (org-mode-hook . org-superstar-mode))
#+END_SRC

** Indentation
As some headers can go very deep I am not a big fan of the default
indentation that increases for each level of header.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :custom
  (org-adapt-indentation nil)
  (org-indent-indentation-per-level 0))
#+END_SRC

** Markup
Just like with links I think we can hide the emphasis markers like =/=
or =*= when marking up text to be italic or bold.
#+BEGIN_SRC emacs-lisp
(use-package emacs
  :custom
  (org-hide-emphasis-markers t))
#+END_SRC

** Images
By default images are shown in their original width, this is most likely
too wide. Therefore we can use the =#+ATTR_ORG: :width 250px= attribute
above each image. This however only works if we set the
=org-image-actual-with= variable to =nil=.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :custom
  (org-image-actual-width nil)
  (org-startup-with-inline-images t))
#+END_SRC

Especially when making notes there is a lot of friction into adding
images. The most simple solution would be to be able to drag images into
Emacs which would place the image at the position of the cursor. This
would require moving the image to some local =img/= directory (as most
images are likely to be temporary screenshots) and inserting the
required org-mode boilerplate to define the image.

Luckily such a package already exists and is called [[https://github.com/abo-abo/org-download][org-download]].

#+BEGIN_SRC emacs-lisp
(defun org-download-annotate-nbelzer (link)
  "Annotate LINK with the time of download."
)

(use-package org-download
  :ensure
  :after org
  :defer 1
  :custom
  ; By default always use a local directory for storing images.
  (org-download-image-dir "./img")
  (org-download-annotate-function (lambda (link) "")))
#+END_SRC

** Source code blocks
By default org mode seems to require indentation in src code blocks, I
don't think this is neccesary so  I disabled it.

#+BEGIN_SRC emacs-lisp
(use-package org-src
  :after org
  :defer t
  :custom
  (org-src-preserve-indentation t)
  (org-edit-src-content-indentation 0))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ob-python
  :defer t
  :ensure org-plus-contrib
  :commands (org-babel-execute:python))

(use-package ob-sqlite
  :defer t
  :ensure org-plus-contrib
  :commands
  (org-babel-execute:sqlite
   org-babel-expand-body:sqlite))

(use-package slime
  :defer t
  :custom
  (inferior-lisp-program "clisp"))

(use-package ob-lisp
  :defer t
  :after org
  :commands
  (org-babel-execute:lisp))
#+END_SRC

** Latex
To support latex code we need to install both Latex and dvipng. Both can be done through the following commands on macOS.

#+BEGIN_EXAMPLE bash
brew cask install basictex
sudo tlmgr update --self
sudo tlmgr install dvisvgm
#+END_EXAMPLE

Based on [[https://madcoda.com/2014/04/getting-started-with-texlatex-on-maclinux/][this]] blog post. Math snippets [[https://orgmode.org/manual/LaTeX-math-snippets.html][can then be enabled by]] including
=#+OPTIONS: tex:dvisvgm= to the org file.

#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  (org-startup-with-latex-preview t)
  (org-latex-create-formula-image-program 'dvisvgm))
#+END_SRC

Additionally we will use [[https://github.com/io12/org-fragtog][org-fragtog]] to automate the toggling inline latex
fragments when the cursor moves over a latex fragment. This means we
always show the rendered fragment, unless the cursor is located in the
fragment. To me this seems like the ideal workflow.

#+BEGIN_SRC emacs-lisp
(use-package org-fragtog
  :ensure
  :defer t
  :hook (org-mode-hook . org-fragtog-mode))
#+END_SRC

** Org-roam
Roam is a relatively new online tool that allows a more interlinked-type of note taking. Links to one note automatically create backlinks. This allows easy exploration of your notes (if you take care in creating and linking them).

This system reflects the [[https://en.wikipedia.org/wiki/Zettelkasten][slip-box method]] and the idea is
that once you attain a reasonable number of notes, that all link to each other somehow, you will be able do draw inspiration and knowledge from them. This improves upon hierarchical note taking as what you might write down is more likely to get lost.

Org-roam specifically replicates this behaviour from Roam, allowing easy referencing of other notes in your system. This automatically creates backlinks for those notes. Providing you with both the note and related notes in an instant. Roam and org-roam have the benefit over the handwritten slip-box method in that they can provide more information about your links and backlinks and have a technically infinite storage capacity. One of the major benefits of using the slip-box method did
seem to be in the required concise-ness of the notes. An explanation or thought had to fit on an index card. This can be replicated using some sort of character limit, however I'll first experiment with keeping this in mind while developing my personal slip-box.

+ [[https://blog.viktomas.com/posts/slip-box/][A nice short guide on the Zettelkasten (slip-box) method]]

#+BEGIN_SRC emacs-lisp
(use-package org-roam
  :ensure t
  :defer t
  :init
  (setq org-roam-v2-ack t)
  (org-roam-db-autosync-mode)
  :custom
  (org-roam-directory "~/Documents/org/slip-box/")
  :bind (:map org-roam-mode-map
              (("C-c n l" . org-roam)
               ("C-c n f" . org-roam-find-file)
               ("C-c n g" . org-roam-graph))
         :map org-mode-map
              (("C-c n i" . org-roam-insert))
              (("C-c n I" . org-roam-insert-immediate))))
#+END_SRC

* PDF
=pdf-tools= is a great package for interacting with PDF files in
Emacs. However I had some trouble setting it up due to a 'missing'
dependency: zlib. Even though zlib is installed through brew I had to
inject the following three lines just above the =./configure ...= command
as for some reason just setting them as environment variables through
=setenv= did not work.

#+BEGIN_EXAMPLE bash
export LDFLAGS="-L/usr/local/opt/zlib/lib"
export CPPFLAGS="-I/usr/local/opt/zlib/include"
export PACKAGE_CONFIG_PATH="/usr/local/opt/zlib/lib/pkgconfig"
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :defer t
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :custom
  ; Enable support for retina display.  See
  ; https://github.com/politza/pdf-tools/issues/51#issuecomment-544049068
  (pdf-view-use-scaling t))
#+END_SRC

Next to the installation problem I was having issues with blurry
rendering of the pdf-files (this also applied to org-mode latex). This
was solved by using a mac-specific Emacs build: [[https://bitbucket.org/mituharu/emacs-mac/src/master/][emacs-mac]], which
includes many macOS native features like smooth scrolling.

* Bibtex
For my thesis I need a robust solution to manage my research papers, the relation to other papers, notes and highlights and their bibtex entries. After searching and trying out different programs, like EndNote and Zotero, I found [[https://github.com/tmalsburg/helm-bibtex][bibtex-completion]] which seems to provide the best match with me.

One of the powerful features are [[https://github.com/tmalsburg/helm-bibtex#tag-publications][tags]] to add tags to bibtex
entries. This allows the sorting of entries as =to-read= or =msc-thesis=.

#+BEGIN_SRC emacs-lisp
(use-package bibtex-completion
  :ensure t)

(use-package ivy-bibtex
  :ensure t
  :requires bibtex-completion
  :custom
  ; Required according to the documentation on Github.
  (ivy-re-builders-alist '((ivy-bibtex . ivy--regex-ignore-order)
                           (t . ivy--regex-plus)))
  ; Where the bibtex bibliography is stored.
  (bibtex-completion-bibliography '("~/org/bibtex/bibtex.bib"))
  ; Where the pdf-files can be found.
  (bibtex-completion-library-path '("~/org/bibtex/pdf"))
  ; Where the notes are stored.
  (bibtex-completion-notes-path "~/org/bibtex/notes")

  ; Change bibtex autokey settings
  (bibtex-autokey-name-year-separator "")
  (bibtex-autokey-titleword-separator "-")
  (bibtex-autokey-year-title-separator "-")
  (bibtex-autokey-titlewords 2)
  (bibtex-autokey-titlewords-stretch 1)
  (bibtex-autokey-titleword-length 5)

  ; Allow search by tags.
  (bibtex-completion-additional-search-fields '(tags))
  ; Open pdf files with the system viewer (on macOS) as I have been
  ; unable to annotate the pdf in pdf-tools.
  (bibtex-completion-pdf-open-function
   (lambda (fpath)
     (start-process "open" "*open*" "open" fpath))))
#+END_SRC

Similarly [[https://github.com/jkitchin/org-ref/][org-ref]] builds upon this and allows citation of your bibtex items in org-buffers. Next to this many other small features are included like creating bibtex entries through a DOI, including downloading of the related pdf.

#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :requires bibtex-completion
  :ensure t
  :defer 2
  :custom
  (org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))
  (org-ref-default-bibliography '("~/org/bibtex/bibtex.bib"))
  (org-ref-bibliography-notes "~/org/bibtex/notes/")
  (org-ref-pdf-directory "~/org/bibtex/pdf/"))
#+END_SRC

* Markdown-mode
#+BEGIN_SRC emacs-lisp
(use-package emacs
  :hook (markdown-mode-hook . olivetti-mode))
#+END_SRC

* Spelling
Spell checking is one of the great things that computers can help us with, whether accidental or not the computer should help us out and point us to possible errors.

There seem to be two main back-ends used for spell checking, Aspell and Hunspell. At the time of writing (July 2020) Aspell last release was =0.60.8= (13 Oct 2019) while Hunspell's latest release was =1.7.0= (12 Nov 2018). For now I've chosen to use =aspell=.

By installing =aspell= using =brew install aspell= we gain some nice auto-correct features using the default =ispell-mode=. However I want to this behaviour:
+ The spell checking should happen in the background, only requiring my attention when something is misspelled.
+ The way it should ask for my attention is by highlighting the word (perhaps in red).
+ It should be activated by default in text buffers such as =org-mode=, =markdown= and git commits.

*Example*: misspeled word
Try correcting the word with =M-$= which calls =ispell-word=.

#+BEGIN_SRC emacs-lisp
; Ispell uses the aspell backend.
(use-package ispell
  :ensure t
  :defer t
  :custom
  (ispell-program-name "aspell")
  ; Increase suggestion speed.
  (ispell-extra-args '("--sug-mode=ultra")))

; Flyspell highlights incorrect words on change
(use-package flyspell
  :ensure t
  :defer t
  :hook (text-mode-hook . flyspell-mode)
  :bind (("C-$" . flyspell-buffer)
         :map flyspell-mode-map
         ("C-;" . nil)
         ("C-," . nil)
         ("C-." . nil)))
#+END_SRC
* RFC Reading
Emacs is a great application to read RFCs in. With the help of [[https://github.com/galdor/rfc-mode][rfc-mode]] it is also possible to quickly jump between different RFCs.

#+BEGIN_SRC emacs-lisp
(use-package rfc-mode
  :ensure t
  :defer t
  :custom
  (rfc-mode-directory (expand-file-name "~/Documents/rfc/")))
#+END_SRC
* Custom functions
Here I define custom functions that are not related to some specific
functionality. These functions are prefixed with =nbelzer/=.

#+BEGIN_SRC emacs-lisp
(defun nbelzer/enable-light-theme ()
  "Enables my preferred light theme."
  (interactive)
  (load-theme 'modus-operandi t))

(defun nbelzer/enable-dark-theme ()
  "Enables my preferred dark theme."
  (interactive)
  (load-theme 'modus-vivendi t))

(defun nbelzer/open-emacs-config ()
  "Opens my emacs configuration file."
  (interactive)
  (find-file "~/.emacs.d/emacs-init.org"))

(defun nbelzer/reload-emacs-config ()
  "Reloads the emacs configuration."
  (interactive)
  (load-file "~/.emacs.d/init.el"))
#+END_SRC
